//Отличие примитивного типа от ссылочного
const obj1 = {
  x: 5,
};

const obj2 = obj1;

obj2.x = 8;

console.log(obj1.x); // 8

let a = 5;
let b = a;

b = 9;

console.log(a); // 5
console.log(b); // 9

//Приведение типов примитивов
console.log(true + false); // 1 Оператор + с двумя операндами вызывает преобразование к числу для true и false
console.log(12 / "6"); //2 Арифметический оператор деления, /, вызывает преобразование к числу для строки '6'
console.log(12 < "6"); // false Оператор сравнения > выполняет числовое сравнение
console.log("number" + 15 + 3); // number153 Оператор + имеет ассоциативность слева направо, один операнд является строкой, остальные так же преобразуются в строку
console.log(15 + 3 + "number"); // 18number Операторы работают один за другим. Первый складывает числа, следующий объединяет со строкой
console.log("foo" + +"bar"); // fooNaN Унарный оператор имеет более высокий приоритет, чем бинарный оператор +"bar" вернет NaN
console.log("true" == true); // false Оператор сравнения вызывает численное преобразование левый операнд преобразуется в NaN, логическое значение true преобразуется в 1
console.log(!!"false" == !!"true"); // true Оператор !! конвертирует строки "false" и "true" в логическое true, так как они являются непустыми строкам
console.log(false == "false"); // false Оператор сравнения вызывает численное преобразование правый операнд преобразуется в NaN, логическое значение false преобразуется в 0
console.log(null == ""); // false Значение null равно только null или undefined и ничему больше, особое правило JS
console.log(null > 0); // false Сравнения преобразуют null в число, рассматривая его как 0
console.log(null == 0); // false Значение null равно только null или undefined и ничему больше, особое правило JS
console.log(null >= 0); // true Сравнения преобразуют null в число, рассматривая его как 0
console.log(null == undefined); // true Эти значения равны друг другу и не равны никаким другим значениям, особое правило JS
console.log(null === undefined); // false Эти значения различны, так как различны их типы. null - это объект (хотя и идёт речь о его отсутствии), undefined и имеет тип "undefined"

//Приведение типов с объектами
console.log([1] > null); // true Оператор сравнения > выполняет числовое сравнение [1] и null 1 > 0
console.log([1, 2] > null); // false Оператор сравнения вызывает численное преобразование у массива NaN > 0
console.log(["x"] == "x"); // true Оператор == вызывает для массивов преобразование к числовому типу. Метод объекта Array.valueOf() возвращает сам массив, и это значение
// игнорируется, так как оно не является примитивом. Метод массива toString() преобразует массив ['x'] в строку 'x'
console.log([] + null + 1); // null1 Метод объекта Array valueOf() игнорируется, так как он возвращает сам массив, который примитивом не является.
// Метод массива toString() возвращает пустую строку. На втором шаге вычисляется значение выражения '' + null + 1
console.log([1, 2, 3] == [1, 2, 3]); // false оба массива одного типа. Сравнивается объекты по ссылке, а не по значению. Два разных объекта
console.log([1, 2, 3] === [1, 2, 3]); // false массивы являются объектами, соответственно при сравнении двух объектов, они не будут равны друг другу
console.log({ a: 1 } - 1); // NaN объект не преобразуется в число
console.log({ a: 1 } + 2); // [object Object]2 объект становится строкой при сложении, если один операнд строка, остальные туда же
